# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'UXUI.ui'
#
# Created by: PyQt5 UI code generator 5.15.10
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.
import math
import sys
from tkinter import filedialog
import tkinter as tk
import numpy as np
from PyQt5.QtCore import Qt, pyqtSignal
from PyQt5.QtGui import QPalette, QColor, QFont
from PyQt5.QtWidgets import QApplication, QMainWindow, QVBoxLayout, QWidget, QLabel, QPushButton, QFileDialog, \
    QHBoxLayout
from PyQt5.QtWidgets import QMessageBox
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas
from matplotlib.figure import Figure
from scipy.optimize import curve_fit, minimize
from scipy.signal import savgol_filter, find_peaks
from scipy.stats import cauchy
from scipy.stats import norm


class Model:
    def __init__(self):
        self.data = None
        self.bad_data = None
        self.lent = None
        self.peaks = None
        self.all_params = None
        self.all_segments = None
        self.ini_x_val = None
        self.ini_y_val = None

    @staticmethod
    def find_peak_limits(y_vals, peak_idx, threshold_ratio=0.05):
        # Находим начало пика
        span = 15
        start = peak_idx - span
        med = np.median(y_vals)
        maxim = np.max(y_vals)
        # minim = np.min(y_vals)
        i = 0
        while start - i >= 0:
            mini = np.min(y_vals[start - i:peak_idx + 1 - i])
            maxi = np.max(y_vals[start - i:peak_idx + 1 - i])
            mean = np.mean(y_vals[start - i:peak_idx + 1 - i])
            if mean >= 0.35 * maxim:
                threshold_ratio = 0.01
            else:
                threshold_ratio = 0.05
            if y_vals[start - i] > 1.05 * y_vals[peak_idx + 1 - i]:
                break
            if maxi - mini > max(med * threshold_ratio, 2):
                i = i + 1
            else:
                break  # Условие прекращения: разница меньше порога
        start = start - i + span  # Убедимся, что индекс не выходит за пределы диапазона
        if start < 0:
            start = 0

        # Находим конец пика
        end = peak_idx + span
        i = 0
        while end + i <= len(y_vals) - 2:
            mini = np.min(y_vals[peak_idx + i:end + 1 + i])
            maxi = np.max(y_vals[peak_idx + i:end + 1 + i])
            mean = np.mean(y_vals[peak_idx + i:end + 1 + i])
            if mean >= 0.35 * maxim:
                threshold_ratio = 0.01
            else:
                threshold_ratio = 0.05
            if 1.05 * y_vals[peak_idx + i] < y_vals[end + 1 + i]:
                break;
            if maxi - mini > max(med * threshold_ratio, 2):
                i = i + 1
            else:
                break  # Условие прекращения: разница меньше порога
        end = end + i  # Убедимся, что индекс не выходит за пределы диапазона
        if end > len(y_vals) - 1:
            end = len(y_vals) - 1
        return start, end

    def load_data(self, filename):
        try:
            self.data = np.loadtxt(filename, dtype=float)
            self.bad_data = self.data.copy()
            self.lent = len(self.data)
            self.smooth_outliers()
            return True
        except Exception as e:
            print(f"Ошибка при загрузке данных: {e}")
            return False

    @staticmethod
    def moving_average_preserve_edges(data, window_size):
        if window_size <= 1 or len(data) < window_size:
            return data

        half_window = window_size // 2
        averages = np.empty_like(data)

        # Начальные элементы оставляем без изменений
        averages[:half_window] = data[:half_window]

        # Вычисление скользящих средних для середины списка
        for i in range(half_window, len(data) - half_window):
            window = data[i - half_window:i + half_window + 1]
            window_average = window.mean()
            averages[i] = window_average

        # Конечные элементы оставляем без изменений
        averages[-half_window:] = data[-half_window:]

        return averages

    @staticmethod
    def remove_duplicates(points):
        unique_points = set()
        result = []
        for x, y in points:
            if (x, y) not in unique_points:
                unique_points.add((x, y))
                result.append((x, y))
        return result

    @staticmethod
    def cauchy_distribution(x, x0, gamma, amplitude, n):
        return math.fabs(n) + amplitude * norm.pdf(x, loc=x0, scale=gamma)

    @staticmethod
    def cauchy_distribution2(x, x0, gamma, amplitude, n):
        return math.fabs(n) + amplitude * cauchy.pdf(x, loc=x0, scale=gamma)

    @staticmethod
    def calculate_rmse(params, x_data, y_data, x_data_peak=[], y_data_peak=[]):
        # Вычисление предсказанных значений с текущими параметрами модели
        max_penalty = 0
        predicted = Model.cauchy_distribution(x_data, *params)
        # Расчет RMSE
        rmse = np.sqrt(np.mean((y_data - predicted) ** 2))
        # Вычисление штрафа за превышение высоты
        return rmse

    @staticmethod
    def calculate_rmse2(params, x_data, y_data, x_data_peak=[], y_data_peak=[]):
        # Вычисление предсказанных значений с текущими параметрами модели
        max_penalty = 0
        predicted = Model.cauchy_distribution2(x_data, *params)
        # Расчет RMSE
        rmse = np.sqrt(np.mean((y_data - predicted) ** 2))
        # Вычисление штрафа за превышение высоты
        return rmse

    def start_end_Koshi(self, x_vals, y_vals, start, end):
        x_fit = x_vals[start:end + 1]
        y_fit = y_vals[start:end + 1]
        self.Optimization(y_fit, x_fit)

    def getKoshiData(self):
        self.all_params = []
        self.all_segments = []
        self.ini_x_val = []
        self.ini_y_val = []
        self.peaks = Model.remove_duplicates(self.peaks)
        for peak in self.peaks:
            self.start_end_Koshi(self.data[:, 0], self.data[:, 1], peak[0], peak[1])
        for i in range(0, len(self.all_segments)):
            params = self.all_params[i]
            auth = Model.cauchy_distribution(self.ini_x_val[i], *params)
            print(auth[0])
            print(self.ini_x_val[0][0])
            # if auth[0] > self.data[np.where(self.data[:, 0] == round(self.ini_x_val[0][0]),2)]:
            #   self.all_params[i][3] = self.data[np.where(self.data[:, 0] == self.ini_x_val[0])[0]]
            # for x, y in self.data:
            #     if x == self.ini_x_val[i][0] and y < math.fabs(auth[0]):
            #         self.all_params[i][3] -= (math.fabs(auth[0])-y) -5
            #         break

    def Optimization(self, y_values, x_values):
        segment_increment = len(y_values) // 15  # Шаг увеличения сегмента
        threshold_rmse = 12  # Порог для RMSE

        # Функция для подгонки и оценки распределения Коши с улучшенной проверкой
        # Список для сохранения параметров успешных подгонок и диапазонов
        max_index = len(y_values) - 1
        current_start_index = 0
        initial_params = [x_values[np.argmax(y_values)], 1, np.max(y_values), 10]
        result = minimize(Model.calculate_rmse, initial_params, args=(x_values, y_values, x_values,
                                                                      y_values),
                          method='Nelder-Mead', options={'maxiter': 2500})
        result2 = minimize(Model.calculate_rmse2, initial_params, args=(x_values, y_values, x_values,
                                                                        y_values),
                           method='Nelder-Mead', options={'maxiter': 2500})
        if result.fun > result2.fun:
            res = result2
        else:
            res = result
        if res.fun < 20.5:
            print(f'результат примерки = {result.fun}, {result2.fun}')
            self.all_params.append(res.x)
            self.ini_x_val.append(x_values)
            self.ini_y_val.append(y_values)
            self.all_segments.append((0, max_index))
            return
        while current_start_index <= max_index - 2:
            if max_index < current_start_index + segment_increment:
                current_end_index = max_index - 1
            else:
                current_end_index = current_start_index + segment_increment
            current_x = x_values[current_start_index:current_end_index]
            current_y = y_values[current_start_index:current_end_index]
            # Начальные параметры для текущего сегмента
            initial_params = [current_x[np.argmax(current_y)], 1, np.max(current_y), 10]
            result = minimize(Model.calculate_rmse, initial_params, args=(current_x, current_y, x_values,
                                                                          y_values),
                              method='Nelder-Mead', options={'maxiter': 2500})
            current_rmse = result.fun
            optimized_params = result.x
            if current_rmse < threshold_rmse and current_end_index <= max_index - 2:
                # Если подгонка успешна и RMSE ниже порога, сохраняем параметры и продолжаем расширять сегмент
                while current_rmse < threshold_rmse and current_end_index <= max_index - 2:
                    if max_index < current_end_index + segment_increment:
                        current_end_index = max_index - 1
                    else:
                        current_end_index = current_end_index + segment_increment
                    initial_x = (np.median(current_x))
                    initial_y = current_y[np.where(np.median(current_x))][0]
                    initial_params = [current_x[np.argmax(current_y)], 1, np.max(current_y), 10]
                    current_x = x_values[current_start_index:current_end_index]
                    current_y = y_values[current_start_index:current_end_index]
                    result = minimize(Model.calculate_rmse, initial_params, args=(current_x, current_y, x_values,
                                                                                  y_values),
                                      method='Nelder-Mead', options={'maxiter': 2500})

                    current_rmse = result.fun
                    if current_rmse < threshold_rmse:
                        optimized_params = result.x

                    # current_rmse = calculate_rmse(current_y, predicted_y)

                # После превышения RMSE, начинаем новый сегмент
                self.all_params.append(optimized_params)
                self.ini_x_val.append(x_values[current_start_index:current_end_index + 1])
                self.ini_y_val.append(y_values[current_start_index:current_end_index + 1])
                print(f'старт {current_start_index}, конец {current_end_index}, параметры: {optimized_params}')
                self.all_segments.append((current_start_index, current_end_index))
                current_start_index = current_end_index + segment_increment // 2
            else:
                print(f'{current_start_index} new')
                # Если RMSE сразу высокий, начинаем новый сегмент
                current_start_index = current_end_index

    @staticmethod
    def adaptive_smoothing(y, window_length_factor=0.2):
        smoothed_y = np.zeros_like(y)
        maxi = np.max(y[len(y) // 10:])
        mini = np.min(y)
        mean = np.mean(y)
        print(mini)
        for i in range(len(y)):
            # Determine window length proportional to y value
            window_length = max(21, int(abs((maxi - y[i]) * window_length_factor) // 2 * 2 + 1))
            polyorder = max(3, window_length // 15)
            if window_length >= 70:
                window_length = 21
                polyorder = 7
            if y[i] < mean * 0.8:
                window_length = 101
                polyorder = 2
            smoothed_y[i] = savgol_filter(y, window_length=window_length, polyorder=polyorder, mode='nearest')[i]
        smoothed_y[0] = y[0]
        return smoothed_y

    def smooth_outliers(self, threshold=0):
        self.peaks = []
        self.data[:, 1] = Model.adaptive_smoothing(self.data[:, 1])
        peaks, properties = find_peaks(self.data[:, 1], prominence=30)
        for i in range(0, len(peaks)):
            st, end = Model.find_peak_limits(self.data[:, 1], peaks[i])
            self.peaks.append((st, end))
        print(self.peaks)
        self.getKoshiData()

    def getBaseline(self):
        y_smoothed_adaptive = self.data[:, 1]
        baseline = []
        cnt = 0
        for peak in self.peaks:
            # перед пиком
            start = peak[0]
            print(f'начало пика {peak}: {start}')
            print(cnt)
            for i in range(0, len(y_smoothed_adaptive) // 5):
                if start == 0:
                    break
                if cnt != 0:
                    if start >= self.peaks[cnt - 1][1]:
                        break
                baseline.append(start)
                start -= 1
            end = peak[1]
            for i in range(0, len(y_smoothed_adaptive) // 5):
                if end == len(y_smoothed_adaptive) - 1:
                    break
                if cnt != len(self.peaks) - 1:
                    if end >= self.peaks[cnt + 1][0]:
                        break
                baseline.append(end)
                end += 1
            cnt += 1
        original_list = list(zip(self.data[:, 0], y_smoothed_adaptive))
        new_list = [original_list[i] for i in baseline]
        x_values, y_values = zip(*new_list)
        coefficients = np.polyfit(x_values, y_values, 6)
        polynomial = np.poly1d(coefficients)
        x_line = np.linspace(min(self.data[:, 0]), max(self.data[:, 0]), len(self.data))
        y_line = polynomial(x_line)
        return x_line, y_line

    @staticmethod
    def getSecondCrossPoint(gauss, baseline, height):
        e = 7
        while height != len(baseline):
            if math.fabs(gauss[height] - baseline[height]) < e:
                return height
            height += 1
        return len(baseline) - 1

    @staticmethod
    def getFirstCrossPoint(gauss, baseline, height):
        e = 7
        while height != -1:
            if math.fabs(gauss[height] - baseline[height]) < e:
                return height
            height -= 1
        return len(baseline) - 1

    @staticmethod
    def CalculateS(low, high, x1, x2, step):
        s = 0
        for i in range(x1, x2):
            s += ((high[i] - low[i]) + (high[i + 1] - low[i + 1])) / 2 * step
        return s


class View(QMainWindow):
    clicked = pyqtSignal(float, float)
    s = None
    x = None
    h = None

    def __init__(self):
        super().__init__()
        self.setWindowTitle("Application")

        # Установка шрифта Montserrat с изменением размера шрифта
        self.font = QFont("Arial", 15)  # измените число для установки желаемого размера шрифта

        # Главный виджет и слой для него
        self.widget = QWidget()
        self.widget.setStyleSheet("background-color: #fff;")
        self.setCentralWidget(self.widget)
        self.layout = QHBoxLayout(self.widget)
        # layout = QVBoxLayout()

        # колонка с кнопками
        self.button_column = QVBoxLayout()

        # Создаем кнопки индивидуально для лучшей идентификации
        self.button1 = QPushButton("Исходные данные", self)
        # self.button_column.addWidget(self.button1)
        self.style_button_current(self.button1)
        self.button1.setFixedHeight(40)

        self.button2 = QPushButton("Выделение пиков", self)
        # self.button_column.addWidget(self.button2)
        self.style_button(self.button2)
        self.button2.setFixedHeight(40)
        self.button2.setEnabled(False)

        self.button3 = QPushButton("Конечный результат", self)
        # self.button_column.addWidget(self.button3)
        self.style_button(self.button3)
        self.button3.setFixedHeight(40)
        self.button3.setEnabled(False)

        # Установка расстояния между кнопками
        self.button_column.setSpacing(5)

        # Текстовая метка с применением установленного шрифта и его размера
        self.label = QLabel("Нажмите кнопку для загрузки данных")
        self.label.setFont(self.font)  # Применяем шрифт Montserrat с новым размером
        self.label.setFixedHeight(50)  # Увеличиваем высоту метки, если нужно
        self.label.setAlignment(Qt.AlignCenter)

        self.button = QPushButton("Загрузить данные")
        self.button.setFont(self.font)  # Применяем шрифт Montserrat
        self.button.setFixedHeight(40)
        self.style_button(self.button)  # Применяем стилизацию кнопки

        # Текстовая метка с применением установленного шрифта и его размера
        self.labelEnd = QLabel("")
        self.labelEnd.setFont(self.font)  # Применяем шрифт Montserrat с новым размером
        self.labelEnd.setFixedHeight(100)  # Увеличиваем высоту метки, если нужно

        # Область для графика matplotlib
        self.figure = Figure()
        self.canvas = FigureCanvas(self.figure)
        self.ax = self.figure.add_subplot(111)
        self.ax.set_title("Дифрактограмма")  # Применяем шрифт Montserrat к заголовку графика
        self.canvas.mpl_connect('button_press_event', self.on_click)
        self.clear_plot()

        # Добавляем виджеты в слой
        # layout.addWidget(self.label)
        # layout.addWidget(self.canvas, 1)
        # layout.addWidget(self.button)
        self.top_layout = QVBoxLayout()
        self.top_layout.addWidget(self.label)
        self.top_layout.addWidget(self.button)
        self.top_layout.addWidget(self.labelEnd)
        self.top_layout.addWidget(self.canvas)
        self.top_layout.setSpacing(5)
        self.bot_layout = QHBoxLayout()
        self.bot_layout.addWidget(self.button1)
        self.bot_layout.addWidget(self.button2)
        self.bot_layout.addWidget(self.button3)
        self.bot_layout.setSpacing(100)

        # Добавляем левый столбец и верхнюю компоновку в главную компоновку
        self.top_layout.addLayout(self.bot_layout)
        self.layout.addLayout(self.top_layout, 7)  # График и метка получают большую часть пространства

    def highlight_points(self, points):
        """ Выделяет точки на графике """
        for point in points:
            self.ax.plot(point[0], point[1], 'ro')  # 'ro' для красного цвета точек
        self.canvas.draw()

    def style_button(self, button):
        """ Стилизация кнопки """
        button_palette = QPalette()
        button_palette.setColor(QPalette.Button, QColor(211, 211, 211))  # Светло-серый цвет кнопки
        button.setPalette(button_palette)
        button.setStyleSheet(
            "QPushButton {"
            "border: 1px solid gray;"  # Граница
            "border-radius: 20px;"  # Закругление углов
            "background-color: rgb(211, 211, 211);"  # Цвет фона
            "font-size: 20px;"
            "font-weight: bolder"
            "}"
        )

    def style_button_current(self, button):
        """ Стилизация кнопки """
        button_palette = QPalette()
        button_palette.setColor(QPalette.Button, QColor(211, 211, 211))  # Светло-серый цвет кнопки
        button.setPalette(button_palette)
        button.setStyleSheet(
            "QPushButton {"
            "border: 1px solid gray;"  # Граница
            "border-radius: 20px;"  # Закругление углов
            "background-color: rgb(150, 150, 150);"  # Цвет фона
            "font-size: 20px;"
            "font-weight: bolder"
            "}"
        )

    def getKoshi(self, params, segments, initial_x_values, x_data, initial_y_values):
        cnt = 0
        for params, (start, end) in zip(params, segments):
            print(f'старт {start}, конец {end}, параметры: {params}')
            x_min = max(0, np.min(initial_x_values[cnt]) - np.max(x_data) // 5)
            x_max = min(np.max(x_data), np.max(initial_x_values[cnt]) + np.max(x_data) // 5)
            x_range = np.linspace(np.floor(x_min), np.ceil(x_max), 1000)
            res = Model.calculate_rmse(params, initial_x_values[cnt], initial_y_values[cnt])
            res1 = Model.calculate_rmse2(params, initial_x_values[cnt], initial_y_values[cnt])
            print(res, res1)
            if res > res1:
                self.ax.plot(x_range, Model.cauchy_distribution2(x_range, *params), linewidth=2,
                             label=f"Распределение Коши для ({round(np.min(initial_x_values[cnt][0]), 2)}, "
                                   f"{round(np.min(initial_x_values[cnt][len(initial_x_values[cnt]) - 1]), 2)})")
            else:
                self.ax.plot(x_range, Model.cauchy_distribution(x_range, *params), linewidth=2,
                             label=f"Гауссово распределение для ({round(np.min(initial_x_values[cnt][0]), 2)}, "
                                   f"{round(np.min(initial_x_values[cnt][len(initial_x_values[cnt]) - 1]), 2)})")

            cnt += 1
        self.ax.legend(loc='upper left')
        self.canvas.draw()

    def on_click(self, event):
        """ Эмиттирует сигнал с координатами клика """
        if event.inaxes:
            x, y = event.xdata, event.ydata
            self.clicked.emit(x, y)  # Эмиттирование сигнала с координатами клик

    def clear_plot(self):
        """ Очистить график """
        self.ax.cla()
        self.ax.set_title("Дифрактограмма")  # Применяем шрифт Montserrat
        self.ax.set_xlabel("2θ")
        self.ax.set_ylabel("Интенсивность I")
        self.ax.plot([], [])  # Пустой график
        self.canvas.draw()
        self.label.setText('Нажмите кнопку для загрузки данных')

    def plot_data(self, x, y):
        """ Обновить график данными """
        self.ax.cla()
        self.ax.set_title("Дифрактограмма")  # Применяем шрифт Montserrat
        self.ax.set_xlabel("2θ")
        self.ax.set_ylabel("Интенсивность I")
        self.ax.plot(x, y, color="#000")
        self.canvas.draw()

    def getBaseline(self, x, y, maxi):
        self.ax.set_ylim(0, maxi * 1.05)
        # print(x)
        self.ax.plot(x, y, color='#c04cfd', label='Подгонка полинома пятой степени', linewidth=3)
        self.ax.legend(loc='upper left')
        self.canvas.draw()

    def getSquareFull(self, x_baseline, y_baseline, y_gauss, x1, x2, s, hx, hy, ind, h):
        print(s, hx, hy, ind, h)
        self.ax.fill_between(x_baseline, y_baseline, y_gauss, where=(x_baseline >= x1) & (x_baseline <= x2),
                             color='gray',
                             alpha=0.3, interpolate=True)

        self.ax.text(hx, hy + 25, f's{ind}={round(s, 1)}, x{ind}={round(hx, 2)}, h{ind}={round(h, 1)}')
        self.s.append(s)
        self.x.append(hx)
        self.h.append(h)
        # legend_proxy = plt.Rectangle((0, 0), 1, 1, fc="w", fill=False, edgecolor='none', linewidth=0)
        # self.ax.legend([legend_proxy], [f'Площадь s{ind}: {s}'], loc='upper right', bbox_to_anchor=(1, 1-0.1*(ind-1)))
        self.canvas.draw()

    def plot_data_pick(self, data):
        """ Обновить график данными """
        x = [point[0] for point in data]
        y = [point[1] for point in data]
        self.ax.plot(x, y, color="black")
        self.canvas.draw()

    def getAns(self):
        ans = ""
        cnt = 1
        cnt_space = 10
        for s in self.s:
            q = len(str(int(s)))
            ans += f's{cnt} = {round(s, 2)}{" " * (20 - 3 * q)}'
            cnt += 1
        ans += "\n"
        cnt = 1
        for h in self.h:
            q = len(str(int(h)))
            ans += f'h{cnt} = {round(h, 2)}{" " * (20 - 3 * q)}'
            cnt += 1
        ans += "\n"
        cnt = 1
        for x in self.x:
            q = len(str(int(x)))
            ans += f'x{cnt} = {round(x, 2)}{" " * (20 - 3 * q)}'
            cnt += 1
        print(ans)
        self.labelEnd.setText(ans)

    def show_error_message(self, message):
        """ Показать сообщение об ошибке """
        error_dialog = QMessageBox()
        error_dialog.setIcon(QMessageBox.Critical)
        error_dialog.setText(message)
        error_dialog.setWindowTitle("Ошибка")
        error_dialog.exec_()


class Controller:
    def __init__(self, view, model):
        self._view = view
        self._model = model
        self._connect_signals()
        self.chosen = 1

    # исходные данные
    def handle_button1(self):
        self._view.labelEnd.setText("")
        if self._view.button2.isEnabled():
            print("in method")
            self.chosen = 1
            self._view.style_button_current(self._view.button1)
            self._view.style_button(self._view.button2)
            self._view.style_button(self._view.button3)
            self._view.plot_data(self._model.bad_data[:, 0], self._model.bad_data[:, 1])
            self._view.label.setText("Выберите нужный файл")
            self._view.button.setText("Загрузить данные")

    # обработанные данные
    def handle_button2(self):
        self._view.labelEnd.setText("")
        self.chosen = 2
        self._view.style_button_current(self._view.button2)
        self._view.style_button(self._view.button1)
        self._view.style_button(self._view.button3)
        self._view.plot_data(self._model.data[:, 0], self._model.data[:, 1])
        self._view.button.setText("Рассчитать показатели")
        self._view.label.setText("Найденные пики")
        self._view.getKoshi(self._model.all_params, self._model.all_segments,
                            self._model.ini_x_val,
                            self._model.data[:, 0], self._model.ini_y_val)

    def handle_button3(self):
        self.find_square()

    def _connect_signals(self):
        self._view.button.clicked.connect(self.load_data)
        self._view.button1.clicked.connect(self.handle_button1)
        self._view.button2.clicked.connect(self.handle_button2)
        self._view.button3.clicked.connect(self.handle_button3)

    def find_square(self):
        self.chosen = 3
        try:
            self._view.button3.setEnabled(True)
            self._view.button.setText("Сохранить график")
            self._view.label.setText("Конечный результат")
            self._view.style_button_current(self._view.button3)
            self._view.style_button(self._view.button2)
            self._view.style_button(self._view.button1)
            x, y = self._model.getBaseline()
            maxi = np.max(self._model.data[:, 1])
            self._view.getBaseline(x, y, maxi)
            self.getCrossPoints()
        except Exception as e:
            print(f"Ошибка: {e}")

    def getCrossPoints(self):
        baseline_x, baseline_y = self._model.getBaseline()
        step = baseline_x[1] - baseline_x[0]
        self._view.s = []
        self._view.h = []
        self._view.x = []
        for i in range(0, len(self._model.all_params)):
            ind_height = round((self._model.all_params[i][0] - baseline_x[0]) / step)
            print(f'вершина {ind_height, self._model.all_params[i][0]}')
            params = self._model.all_params[i]
            res = Model.calculate_rmse(params, self._model.ini_x_val[i], self._model.ini_y_val[i])
            res1 = Model.calculate_rmse2(params, self._model.ini_x_val[i], self._model.ini_y_val[i])
            print(res, res1)
            if res > res1:
                gauss_y = Model.cauchy_distribution2(baseline_x, *params)
            else:
                gauss_y = Model.cauchy_distribution(baseline_x, *params)
            x1 = Model.getFirstCrossPoint(gauss_y, baseline_y, ind_height)
            x2 = Model.getSecondCrossPoint(gauss_y, baseline_y, ind_height)
            h = gauss_y[ind_height] - baseline_y[ind_height]
            # CalculateS(low, high,x1,x2, step)
            s = Model.CalculateS(baseline_y, gauss_y, x1, x2, step)
            x1 = x1 * step + baseline_x[0]
            x2 = x2 * step + baseline_x[0]
            # def getSquareFull(self, x_baseline, y_baseline, y_gauss, x1,x2,s,hx,hy,ind,h):
            # print(s,hx,hy,ind,h)
            self._view.getSquareFull(baseline_x, baseline_y, gauss_y, x1, x2, s, self._model.all_params[i][0],
                                     gauss_y[ind_height], i + 1, h)
        self._view.getAns()

    def save(self):
        try:
            root = tk.Tk()
            root.withdraw()  # Скрыть основное окно Tkinter
            file_path = filedialog.asksaveasfilename(defaultextension=".png",
                                                     filetypes=[("PNG files", "*.png"), ("All Files", "*.*")])
            if file_path:
                # Сохранение графика в выбранном местоположении
                self._view.ax.figure.savefig(file_path)
        except Exception as e:
            print(f"Ошибка: {e}")

    def load_data(self):
        if self.chosen == 2:
            self.find_square()
            return
        elif self.chosen == 3:
            self.save()
            return
        filename, _ = QFileDialog.getOpenFileName(self._view, "Открыть файл данных", "", "Text files (*.txt)")
        if filename:
            success = self._model.load_data(filename)
            if success:
                if self._model.data.shape[1] != 2:
                    self._view.show_error_message("Неправильный формат данных в файле")
                else:
                    self._view.button2.setEnabled(True)
                    self._view.button3.setEnabled(False)
                    self._view.style_button_current(self._view.button2)
                    self._view.style_button(self._view.button1)
                    self._view.style_button(self._view.button3)
                    self._view.plot_data(self._model.data[:, 0], self._model.data[:, 1])
                    self._view.getKoshi(self._model.all_params, self._model.all_segments,
                                        self._model.ini_x_val,
                                        self._model.data[:, 0], self._model.ini_y_val)
                    self.chosen = 2
                    self._view.button.setText("Рассчитать показатели")
                    self._view.label.setText("Найденные пики")
            else:
                self._view.show_error_message("Неправильный формат данных в файле")


def main():
    app = QApplication(sys.argv)
    app.setAttribute(Qt.AA_DisableWindowContextHelpButton)
    screen = app.primaryScreen()

    model = Model()
    view = View()
    rect = screen.availableGeometry()
    # Устанавливаем размер и позицию окна
    width = rect.width() * 0.9  # Ширина окна - 80% ширины экрана
    height = rect.height() * 0.95  # Высота окна - 90% высоты экрана
    x = (rect.width() - width) / 2  # Горизонтальное позиционирование
    y = (rect.height() - height)  # Вертикальное позиционирование

    view.setGeometry(int(x), int(y), int(width), int(height))
    view.setFixedSize(int(width), int(height))  # Фиксированный размер окна

    controller = Controller(view, model)

    view.show()
    sys.exit(app.exec_())


if __name__ == "__main__":
    main()
